## RGB to YCbCr conversions

### Overview

This XCode playground shows how to process files produced by *ffmpeg** using Apple's Accelerate and Metal frameworks. Since the files generated consists of raw pixel data, there is no information about the width and height of the original image/frame. We could name a file as *test420p_640x640.yuv* instead of *test420p.yuv*.

There is direct support for creating planar CVPixelBuffers objects from  raw 420 planar files. Currently, there is no support for 4:2:2 or 4:4:4  planar CVPixelBuffer objects on macOS/iOS.

There is indirect support for 4:2:2 uyvy or 4:2:2: yuyv raw files. These 2 corresponds to 
 and kvImage422CbYpCrYp8 (2vuy)  and kvImage422YpCbYpCr8 (yuvs /yuvf) respectively.  But the raw data must be processed to produced data chunks of {Cb, Yp, Cr, Yp} or  {Yp, Cb, Yp, Cr} before the calling the function :

    vImageConvert_422CbYpCrYp8ToARGB8888
    
or 

    vImageConvert_422YpCbYpCr8ToARGB8888
    

to decode the pixels in YpCbCr colour space to RGB colourspace. The demo **yuv422PlanarToARGBConversion** presumes the raw data will using the first function (2vuy). How to use the second function will be left as an exercise to the reader.


**Generating 422p files**

The files with the main **Resources** folder, *Hibiscus422p.yuv* and *PinkFlower422p.yuv*, are generated by executing the demo **yuv422ToPlanarConversion** while the third file, *test422p.yuv* is generated by the utility **ffmpeg**

There are 5 tasks to be executed:
(a) load a graphic file and create a vImage_Buffer object *rgbaSourceBuffer* to encapsulate the RGBA pixels.
(b) convert interleaved RGBA pixels to chunks of interleaved {Yp0 Cb0 Yp1 Cr0}.
(c) convert the chunks to 2 vImage_Buffer objects encapsulating Yp pixels and CbCr pixels.
(d) convert the chunks of interleaved CbCr {Cb0 Cr0} into another 2 vImage_Buffer objects.
(e) merge the Yp, Cb, Cr pixels in the 3 vImage_Buffer objects in a single block of data.

Task (b) is performed by calling the following function:

    vImageConvert_ARGB8888To422YpCbYpCr8

Tasks (c) and (d) will call the following function:

    vImageConvert_ChunkyToPlanar8

There will be 3 planes of raw data encapsulated in 3 vImage_Buffer objects. The first plane, *yPlane*, consists of bytes of the luminance channel, *uPlane*, the bytes of the chrominance BLUE difference channel and *vPlane*, the  bytes of the chrominance RED difference channel. 

Task (e) is performed by a custom function **mergeBuffers** on the 3 vImage_Buffer objects.

Finally, all that remains is writing out the raw data to the folder ~/Documents/"Shared Playground Data".



**Processing 422p files**

To execute the playground demo **yuv422PlanarToARGBConversion**, set it to load one of the following files from the  main **Resources** folder: *Hibiscus422p.yuv*, *PinkFlower422p.yuv* and *test422p.yuv*. 

Each of these files consists of the raw data of 3 planes viz. Yp, Cb, and Cr planes. Since these files don't have any file header, the width and height of the RGB image (from which they were generated from) must be known beforehand. One method is to specify their resolution as part of their names e.g.  Hibiscus422p_800x600.yuv, PinkFlower422p_640x480.yuv and test422p_640x640.yuv.

Before executing the underlying code of **yuv422PlanarToARGBConversion**, the following constants must be assigned correctly.

a) inputFilename
b) width
c) height

of the original graphic file which was used to generate the *yuv* file.

There are t tasks to be executed:
(a) load the specified *yuv* file and create 3 vImage_Buffer objects with their **data** properties pointing to the memory blocks containing  Yp, Cb and Cr pixels. These are the source planar buffers.
(b) convert the Cb and Cr pixels from the source vImage_Buffer, `cbBuffer` and `crBuffer` into interleaved {Cb, Cr} chunks
(c) convert the interleaved {Cb, Cr} chunks with the Yp pixels from `yBuffer` to produce interleaved {Cb0 Yp0 Cr0 Yp1} chunks
(d) convert the YpCbCr pixels into RGBA pixels

Both tasks (b) and (c) are performed by executing the  following function:

    vImageConvert_PlanarToChunky8

Task (d) is performed by  executing the  following function:

    vImageConvert_422CbYpCrYp8ToARGB8888

A visual check is done by creating an instance of CGImage from the RGBA vImage_Buffer object

The code for the 2 playgrounds of **RBG_YUV444_Conversions** are simpler.
